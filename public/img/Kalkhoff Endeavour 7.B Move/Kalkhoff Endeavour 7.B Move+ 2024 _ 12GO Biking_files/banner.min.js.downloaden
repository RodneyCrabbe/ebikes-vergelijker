// @ts-check
/**
 * @type {boolean} - Whether the groups have been rendered yet. Prevents rendering multiple times.
 */
let isGroupsRendered = false;
/**
 * @type {HTMLElement | null} - The dialog with cookie details
 */
const details = document.getElementById("_ec-details");
/**
 * @type {HTMLElement | null} - The default dialog that is first shown to the user
 */
const defaultDialog = document.getElementById("_ec-default");
/**
 * The current history cookie object
 */
const jsonElement = document.getElementById("_ec-json")?.textContent;
/**
 * @typedef Cookie
 * @property {string} name
 * @property {string} provider
 * @property {string} group
 * @property {string} description
 * @property {string} retention
 * @property {string} type
 */
/**
 * @typedef Provider
 * @property {string} name
 * @property {string} description
 * @property {string} url
 */
/**
 * @typedef Group
 * @property {string} identifier
 * @property {string} name
 * @property {string} description
 */
/**
 * @type {{
 * cookies: Cookie[],
 * providers: Provider[],
 * groups: Group[],
 * }}
 */
const json = JSON.parse(jsonElement ?? "{}");

/**
 * Get all groups from the Cookie JSON object
 * @returns {string[]} - An array of unique group names
 */
function getGroups() {
    return json.groups.map((g) => g.identifier);
}

/**
 * @typedef ConsentStatus
 *
 * @property {string} hash Hash of the last cookie configuration
 * @property {string} user Random user ID
 * @property {string[]} [groups] Array of groups that have consent
 * @property {boolean} [all] True if all groups have consent
 * @property {boolean} [none] True if no groups have consent
 */
/**
 * Logs the consent status using the GraphQL API
 * @param {ConsentStatus} consent
 */
async function logConsent(consent) {
    const graphqlHeaders = new Headers();
    graphqlHeaders.append("Content-Type", "application/json");
    graphqlHeaders.append("Accept", "application/json");

    const hash = consent.hash;
    const allGroups = getGroups();
    const groups = consent.none
        ? []
        : consent.all
          ? allGroups.filter((g) => g !== "essential")
          : consent.groups;

    fetch("/graphql", {
        method: "POST",
        headers: graphqlHeaders,
        body: JSON.stringify({
            query: `mutation ($input: Consent!) {
                logCookies(input: $input) {
                    success
                    message
                }
            }`,
            variables: {
                input: {
                    hash,
                    user: consent.user,
                    groups,
                },
            },
        }),
    });
}

/**
 * Groups an array of objects by a specified key or key-generation function
 * @param {Array} array - The array to group
 * @param {string|function} key - The key to group by, or a function that returns the grouping key
 * @returns {Object} An object where keys are group identifiers and values are arrays of grouped items
 */
function groupBy(array, key) {
    // If key is a string, create a function that extracts that property
    const keyFunc = typeof key === "string" ? (item) => item[key] : key;
    return array.reduce((grouped, item) => {
        // Get the group key for this item
        const groupKey = keyFunc(item);

        // If the group doesn't exist, create it
        if (!grouped[groupKey]) {
            grouped[groupKey] = [];
        }

        // Add the item to its group
        grouped[groupKey].push(item);

        return grouped;
    }, {});
}

/**
 * Renders the groups in the dialog
 * @returns {void}
 */
function renderGroups() {
    if (isGroupsRendered) {
        return;
    }
    isGroupsRendered = true;

    /**
     * @type {HTMLTemplateElement|null} - The template for a group
     */
    const groupTemplate = /** @type {HTMLTemplateElement|null} */ (
        document.getElementById("_ec-group-tpl")
    );
    /**
     * @type {HTMLTemplateElement|null} - The template for a provider
     */
    const providerTemplate = /** @type {HTMLTemplateElement|null} */ (
        document.getElementById("_ec-provider-tpl")
    );
    /**
     * @type {HTMLTemplateElement|null} - The template for a cookie
     */
    const cookieTemplate = /** @type {HTMLTemplateElement|null} */ (
        document.getElementById("_ec-cookie-tpl")
    );
    /**
     * @type {HTMLElement|null} - The target element for the rendered groups
     */
    const groupsTarget = /** @type {HTMLElement|null} */ (
        document.getElementById("_ec-groups")
    );

    if (!details) {
        throw new Error("Details element not found");
    }

    details
        .querySelectorAll("._ec-proof-hash")
        .forEach((elem) => (elem.textContent = window.cookieApi.hash));
    details
        .querySelectorAll("._ec-proof-user")
        .forEach((elem) => (elem.textContent = window.cookieApi.user));

    for (const group of json.groups) {
        const hasCookies = json.cookies.some(
            (cookie) => cookie.group === group.identifier,
        );
        if (!hasCookies) {
            continue;
        }

        const clone = /** @type {HTMLElement} */ (
            groupTemplate?.content.cloneNode(true)
        );
        clone
            ?.querySelectorAll("._ec-group-name")
            ?.forEach((elem) => (elem.textContent = group.name));
        clone
            .querySelectorAll("._ec-group-description")
            .forEach((elem) => (elem.textContent = group?.description ?? ""));
        const checkbox = /** @type {HTMLInputElement} */ (
            clone.querySelector("._ec-checkbox")
        );
        checkbox.value = group.identifier;
        checkbox.disabled = group.identifier === "essential";
        checkbox.checked =
            group.identifier === "essential" ||
            group.identifier === "functional";

        const providers = groupBy(
            json.cookies.filter((cookie) => cookie.group === group.identifier),
            (/** @type { Cookie } */ cookie) => cookie.provider,
        );

        for (const provider of Object.keys(providers)) {
            const providerInfo = json.providers.find(
                (g) => g.name === provider,
            );
            const providerClone = /** @type {HTMLElement} */ (
                providerTemplate?.content.cloneNode(true)
            );
            providerClone
                ?.querySelectorAll("._ec-provider-name")
                ?.forEach((elem) => (elem.textContent = provider));
            providerClone
                ?.querySelectorAll("._ec-provider-link")
                ?.forEach(
                    (elem) =>
                        /** @type {HTMLAnchorElement} */ (
                            elem.href = providerInfo?.url ?? ""
                        ),
                );
            providerClone
                ?.querySelectorAll("._ec-provider-description")
                ?.forEach(
                    (elem) =>
                        /** @type {HTMLAnchorElement} */ (
                            elem.href = providerInfo?.description ?? ""
                        ),
                );

            for (const cookie of providers[provider]) {
                const cookieClone = /** @type {HTMLElement} */ (
                    cookieTemplate?.content.cloneNode(true)
                );
                cookieClone
                    .querySelectorAll("._ec-name")
                    .forEach((elem) => (elem.textContent = cookie.name));
                cookieClone
                    .querySelectorAll("._ec-type")
                    .forEach((elem) => (elem.textContent = cookie.type));
                cookieClone
                    .querySelectorAll("._ec-retention")
                    .forEach((elem) => (elem.textContent = cookie.retention));
                cookieClone
                    .querySelectorAll("._ec-description")
                    .forEach((elem) => (elem.textContent = cookie.description));
                providerClone.querySelector("._ec-tbody")?.append(cookieClone);
            }

            clone.querySelector("._ec-vendors")?.append(providerClone);
        }

        groupsTarget?.append(clone);
    }
}

// Setup event listeners to render the groups and handle form submission
defaultDialog?.querySelector("._ec-accept-all")?.addEventListener(
    "click",
    () => {
        window.cookieApi?.acceptAll();
    },
    {
        passive: true,
    },
);

defaultDialog?.querySelector("._ec-reject-all")?.addEventListener(
    "click",
    () => {
        window.cookieApi?.declineAll();
    },
    {
        passive: true,
    },
);

defaultDialog?.querySelector("._ec-learn-more")?.addEventListener(
    "click",
    () => {
        renderGroups();
        defaultDialog?.classList.add("hidden");
        details?.classList.remove("hidden");
    },
    {
        passive: true,
    },
);
details?.querySelector("._ec-go-back")?.addEventListener(
    "click",
    () => {
        details?.classList.add("hidden");
        defaultDialog?.classList.remove("hidden");
    },
    {
        passive: true,
    },
);
details?.addEventListener("submit", (e) => {
    if (!(e.currentTarget instanceof HTMLFormElement)) {
        return;
    }
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    window.cookieApi?.acceptGroups(formData.getAll("group"));
});

window.addEventListener("consent-change", (e) => {
    if (e instanceof CustomEvent) {
        logConsent(e.detail);
    }
});
